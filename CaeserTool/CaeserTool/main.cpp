//
//  main.cpp
//  CaeserTool
//
//  Created by 突突兔 on 6/19/19.
//  Copyright © 2019 突突兔. All rights reserved.
//

#include <iostream>
#include <fstream>
#include <string>
#include <stdexcept>
#include <sstream>
#include <vector>
#include <string>

using namespace std;

static const char encodeTable[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00,
    0x46, 0x45, 0x61, 0x33, 0x5A, 0x5F, 0x67, 0x55, 0x2E, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x34, 0x63, 0x37, 0x48, 0x50, 0x42, 0x78, 0x57, 0x65, 0x36, 0x58, 0x51, 0x31, 0x77, 0x4B,
    0x47, 0x7A, 0x54, 0x70, 0x52, 0x4C, 0x6D, 0x66, 0x6F, 0x76, 0x39, 0x00, 0x00, 0x00, 0x00, 0x71,
    0x00, 0x53, 0x6E, 0x30, 0x62, 0x6A, 0x6C, 0x69, 0x79, 0x68, 0x49, 0x72, 0x4E, 0x59, 0x64, 0x56,
    0x6B, 0x38, 0x4F, 0x75, 0x43, 0x73, 0x74, 0x41, 0x32, 0x4A, 0x4D, 0x00, 0x00, 0x00, 0x00, 0x00
};

//static const char decodeTable[] = {
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00,
//    0x63, 0x4D, 0x78, 0x33, 0x41, 0x39, 0x4A, 0x43, 0x71, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x77, 0x46, 0x74, 0x2E, 0x31, 0x30, 0x50, 0x44, 0x6A, 0x79, 0x4F, 0x55, 0x7A, 0x6C, 0x72,
//    0x45, 0x4C, 0x54, 0x61, 0x52, 0x37, 0x6F, 0x48, 0x4B, 0x6D, 0x34, 0x00, 0x00, 0x00, 0x00, 0x35,
//    0x00, 0x32, 0x64, 0x42, 0x6E, 0x49, 0x57, 0x36, 0x69, 0x67, 0x65, 0x70, 0x66, 0x56, 0x62, 0x58,
//    0x53, 0x5F, 0x6B, 0x75, 0x76, 0x73, 0x59, 0x4E, 0x47, 0x68, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00
//};


string CaeserEncode(const string& origin) {
    string s("", origin.size());
    for (size_t i = 0; i < origin.length(); i++) {
        s[i] = encodeTable[origin[i]];
    }
    return s;
}

string CaeserString(const string& source) {
    auto localizeLocation = source.find("TGLocalized(@");
    if (localizeLocation == string::npos) {
        return source;
    }
    int initial = (int)localizeLocation + 14;
    int end = 0;
    for (int i = initial; i < source.size(); i++) {
        char c = source.c_str()[i];
        if (c == '"') {
            end = i;
            break;
        }
    }
    string origin = source.substr(localizeLocation + 14, end - initial);
    string encodeOrigin = CaeserEncode(origin);
    string mutableSource = source;
    string encodeResult = mutableSource.replace(localizeLocation + 14, end - initial, string(encodeOrigin).insert(0, "$"));
    auto newLocalizeLocation = encodeResult.find(encodeOrigin);
    string tt = encodeResult.substr(0, newLocalizeLocation + encodeOrigin.length());
    return tt + CaeserString(encodeResult.substr(end));
}



int main(int argc, const char * argv[]) {
    if (argc != 2) {
        throw invalid_argument("File path needed!");
    }
    const string filePath = argv[1];
    ifstream in(filePath);
    if (!in) {
        throw invalid_argument("File unavailable");
    }
    
    vector<string> results;
    string s;
    while (getline(in, s)) {
        const string encodeResult = CaeserString(s);
        results.push_back(encodeResult);
    }
    in.close();
    
    ofstream out(filePath);
    if (!out) {
        throw logic_error("Invalid file!");
    }
    for (const auto& str : results) {
        out << str << "\n";
    }
    out.close();
    return 0;
}
